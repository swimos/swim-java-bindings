# bytebridge
A tool for deriving a byte representation of a Java class, so it can be more efficiently transferred across the Java Native Interface boundary as opposed to using a FFI builder. Bytebridge derives a Java class and a transformation from a Rust enumeration or struct and also derives a Rust byte reader.

## Example
Suppose that you have a complex configuration class that you need for a FFI function written in Rust:

```rust
pub struct Configuration {
    pub runtime_empty_timeout: std::time::Duration,
    pub runtime_attachment_queue_size: i64,
    pub runtime_abort_on_bad_frames: bool,
    pub runtime_remote_buffer_size: i64,
    pub runtime_downlink_buffer_size: i64,
    pub downlink_events_when_not_synced: bool,
    pub downlink_terminate_on_unlinked: bool,
    pub downlink_buffer_size: i64,
    pub keep_linked: bool,
}

```
There are multiple methods that we could use for receiving these properties in Rust. We could implement a FFI builder around the struct, provide each field as a method parameter or derive a byte representation for it. 

Bytebridge will derive a Java class for building the configuration (with optional constraints on the fields) and then copy the Rust input into a new file. To use it, we need to add some attributes to the fields:

```rust
#[bytebridge]
#[derive(Debug, Clone, PartialEq)]
pub struct Test {
    /// Timeout in seconds. If the runtime has no consumers for longer than this timeout, it will stop.
    #[bytebridge(default_value = 30)]
    pub runtime_empty_timeout: std::time::Duration,
    /// Size of the queue for accepting new subscribers to a downlink.
    #[bytebridge(natural, default_value = 16)]
    pub runtime_attachment_queue_size: i64,
    /// Abort the downlink on receiving invalid frames.
    #[bytebridge(default_value = true)]
    pub runtime_abort_on_bad_frames: bool,
    /// Size of the buffers to communicated with the socket.
    #[bytebridge(natural, default_value = 4096)]
    pub runtime_remote_buffer_size: i64,
    /// Size of the buffers to communicate with the downlink implementation.
    #[bytebridge(natural, default_value = 4096)]
    pub runtime_downlink_buffer_size: i64,
    /// Whether to trigger event handlers if the downlink receives events before it has
    /// synchronized.
    #[bytebridge(default_value = false)]
    pub downlink_events_when_not_synced: bool,
    /// Whether the downlink should terminate on an unlinked message.
    #[bytebridge(default_value = true)]
    pub downlink_terminate_on_unlinked: bool,
    /// Downlink event buffer capacity.
    #[bytebridge(natural, default_value = 1024)]
    pub downlink_buffer_size: i64,
    /// If the connection fails, it should be restarted and the consumer passed to the new
    /// connection.
    #[bytebridge(default_value = true)]
    pub keep_linked: bool,
}
```
Lets put that in our project in a file named 'ffi_models.rs' (don't include it in the source tree). We now need to add a build file with the content of:
```rust
use bytebridge::{FormatStyle, JavaSourceWriterBuilder, RustSourceWriterBuilder};
use std::env;
use std::env::current_dir;
use std::path::{Path, PathBuf};

fn main() {
    let models = Path::new("src").join("ffi_models.rs");
    println!("cargo:rerun-if-changed={}", models.display());

    let mut build_file: PathBuf = env::var("OUT_DIR").unwrap().parse().unwrap();
    build_file.push("out.rs");

    let builder = bytebridge::Builder::default();
    let _java_writer = JavaSourceWriterBuilder::std_out("test.package.somewhere").copyright_header(
        r#"Copyright line 1
Copyright line 2"#,
        FormatStyle::Line,
    );

    let java_writer = JavaSourceWriterBuilder::dir(current_dir().unwrap(), "ai.swim").unwrap();

    let rust_writer = RustSourceWriterBuilder::file(build_file)
        .unwrap()
        .format(true);
    builder
        .add_source(models)
        .generate(java_writer, rust_writer)
        .unwrap();
}
```
When the project is built we will see a new Java file named "Configuration.java" and with the following content:
```java
/// THIS FILE IS AUTOMATICALLY GENERATED BY THE BYTE BRIDGE LIBRARY.
/// ANY CHANGES MADE MAY BE LOST.
package ai.swim;

public class Configuration {

  /**
   * Timeout in seconds. If the runtime has no consumers for longer than this timeout, it will stop.
   */
  private int runtimeEmptyTimeout = 30;

  /**
   * Size of the queue for accepting new subscribers to a downlink.
   */
  private long runtimeAttachmentQueueSize = 16;

  /**
   * Abort the downlink on receiving invalid frames.
   */
  private boolean runtimeAbortOnBadFrames = true;

  /**
   * Size of the buffers to communicated with the socket.
   */
  private long runtimeRemoteBufferSize = 4096;

  /**
   * Size of the buffers to communicate with the downlink implementation.
   */
  private long runtimeDownlinkBufferSize = 4096;

  /**
   * Whether to trigger event handlers if the downlink receives events before it has
   * synchronized.
   */
  private boolean downlinkEventsWhenNotSynced = false;

  /**
   * Whether the downlink should terminate on an unlinked message.
   */
  private boolean downlinkTerminateOnUnlinked = true;

  /**
   * Downlink event buffer capacity.
   */
  private long downlinkBufferSize = 1024;

  /**
   * If the connection fails, it should be restarted and the consumer passed to the new
   * connection.
   */
  private boolean keepLinked = true;

  /**
   * Gets runtimeEmptyTimeout.
   * <p>
   * Default value: 30.
   *
   * @return runtimeEmptyTimeout
   */
  public int getRuntimeEmptyTimeout() {
    return this.runtimeEmptyTimeout;
  }

  /**
   * Sets the new runtimeEmptyTimeout.
   *
   * @param runtimeEmptyTimeout the new runtimeEmptyTimeout
   * @throws IllegalArgumentException if runtimeEmptyTimeout is negative
   */
  public void setRuntimeEmptyTimeout(int runtimeEmptyTimeout) {
    if (runtimeEmptyTimeout < 0) {
      throw new IllegalArgumentException("'runtimeEmptyTimeout' must be positive");
    }
    this.runtimeEmptyTimeout = runtimeEmptyTimeout;
  }

  /**
   * Gets runtimeAttachmentQueueSize.
   * <p>
   * Default value: 16.
   *
   * @return runtimeAttachmentQueueSize
   */
  public long getRuntimeAttachmentQueueSize() {
    return this.runtimeAttachmentQueueSize;
  }

  /**
   * Sets the new runtimeAttachmentQueueSize.
   *
   * @param runtimeAttachmentQueueSize the new runtimeAttachmentQueueSize
   * @throws IllegalArgumentException If 'runtimeAttachmentQueueSize' is not a natural number (< 1).
   */
  public void setRuntimeAttachmentQueueSize(long runtimeAttachmentQueueSize) {
    if (runtimeAttachmentQueueSize < 1) {
      throw new IllegalArgumentException("'runtimeAttachmentQueueSize' must be a natural number");
    }
    this.runtimeAttachmentQueueSize = runtimeAttachmentQueueSize;
  }

  /**
   * Gets runtimeAbortOnBadFrames.
   * <p>
   * Default value: true.
   *
   * @return runtimeAbortOnBadFrames
   */
  public boolean getRuntimeAbortOnBadFrames() {
    return this.runtimeAbortOnBadFrames;
  }

  /**
   * Sets the new runtimeAbortOnBadFrames.
   *
   * @param runtimeAbortOnBadFrames the new runtimeAbortOnBadFrames
   */
  public void setRuntimeAbortOnBadFrames(boolean runtimeAbortOnBadFrames) {
    this.runtimeAbortOnBadFrames = runtimeAbortOnBadFrames;
  }

  /**
   * Gets runtimeRemoteBufferSize.
   * <p>
   * Default value: 4096.
   *
   * @return runtimeRemoteBufferSize
   */
  public long getRuntimeRemoteBufferSize() {
    return this.runtimeRemoteBufferSize;
  }

  /**
   * Sets the new runtimeRemoteBufferSize.
   *
   * @param runtimeRemoteBufferSize the new runtimeRemoteBufferSize
   * @throws IllegalArgumentException If 'runtimeRemoteBufferSize' is not a natural number (< 1).
   */
  public void setRuntimeRemoteBufferSize(long runtimeRemoteBufferSize) {
    if (runtimeRemoteBufferSize < 1) {
      throw new IllegalArgumentException("'runtimeRemoteBufferSize' must be a natural number");
    }
    this.runtimeRemoteBufferSize = runtimeRemoteBufferSize;
  }

  /**
   * Gets runtimeDownlinkBufferSize.
   * <p>
   * Default value: 4096.
   *
   * @return runtimeDownlinkBufferSize
   */
  public long getRuntimeDownlinkBufferSize() {
    return this.runtimeDownlinkBufferSize;
  }

  /**
   * Sets the new runtimeDownlinkBufferSize.
   *
   * @param runtimeDownlinkBufferSize the new runtimeDownlinkBufferSize
   * @throws IllegalArgumentException If 'runtimeDownlinkBufferSize' is not a natural number (< 1).
   */
  public void setRuntimeDownlinkBufferSize(long runtimeDownlinkBufferSize) {
    if (runtimeDownlinkBufferSize < 1) {
      throw new IllegalArgumentException("'runtimeDownlinkBufferSize' must be a natural number");
    }
    this.runtimeDownlinkBufferSize = runtimeDownlinkBufferSize;
  }

  /**
   * Gets downlinkEventsWhenNotSynced.
   * <p>
   * Default value: false.
   *
   * @return downlinkEventsWhenNotSynced
   */
  public boolean getDownlinkEventsWhenNotSynced() {
    return this.downlinkEventsWhenNotSynced;
  }

  /**
   * Sets the new downlinkEventsWhenNotSynced.
   *
   * @param downlinkEventsWhenNotSynced the new downlinkEventsWhenNotSynced
   */
  public void setDownlinkEventsWhenNotSynced(boolean downlinkEventsWhenNotSynced) {
    this.downlinkEventsWhenNotSynced = downlinkEventsWhenNotSynced;
  }

  /**
   * Gets downlinkTerminateOnUnlinked.
   * <p>
   * Default value: true.
   *
   * @return downlinkTerminateOnUnlinked
   */
  public boolean getDownlinkTerminateOnUnlinked() {
    return this.downlinkTerminateOnUnlinked;
  }

  /**
   * Sets the new downlinkTerminateOnUnlinked.
   *
   * @param downlinkTerminateOnUnlinked the new downlinkTerminateOnUnlinked
   */
  public void setDownlinkTerminateOnUnlinked(boolean downlinkTerminateOnUnlinked) {
    this.downlinkTerminateOnUnlinked = downlinkTerminateOnUnlinked;
  }

  /**
   * Gets downlinkBufferSize.
   * <p>
   * Default value: 1024.
   *
   * @return downlinkBufferSize
   */
  public long getDownlinkBufferSize() {
    return this.downlinkBufferSize;
  }

  /**
   * Sets the new downlinkBufferSize.
   *
   * @param downlinkBufferSize the new downlinkBufferSize
   * @throws IllegalArgumentException If 'downlinkBufferSize' is not a natural number (< 1).
   */
  public void setDownlinkBufferSize(long downlinkBufferSize) {
    if (downlinkBufferSize < 1) {
      throw new IllegalArgumentException("'downlinkBufferSize' must be a natural number");
    }
    this.downlinkBufferSize = downlinkBufferSize;
  }

  /**
   * Gets keepLinked.
   * <p>
   * Default value: true.
   *
   * @return keepLinked
   */
  public boolean getKeepLinked() {
    return this.keepLinked;
  }

  /**
   * Sets the new keepLinked.
   *
   * @param keepLinked the new keepLinked
   */
  public void setKeepLinked(boolean keepLinked) {
    this.keepLinked = keepLinked;
  }

  /**
   * Returns a byte array representation of the current configuration.
   */
  public byte[] asBytes() {
    int __buf__size = 0;
    __buf__size += 40;
    java.nio.ByteBuffer __buf = java.nio.ByteBuffer.allocate(__buf__size);
    __buf.order(java.nio.ByteOrder.LITTLE_ENDIAN);
    __buf.putInt(this.runtimeEmptyTimeout);
    __buf.putLong(this.runtimeAttachmentQueueSize);
    __buf.put((byte) (this.runtimeAbortOnBadFrames ? 1 : 0));
    __buf.putLong(this.runtimeRemoteBufferSize);
    __buf.putLong(this.runtimeDownlinkBufferSize);
    __buf.put((byte) (this.downlinkEventsWhenNotSynced ? 1 : 0));
    __buf.put((byte) (this.downlinkTerminateOnUnlinked ? 1 : 0));
    __buf.putLong(this.downlinkBufferSize);
    __buf.put((byte) (this.keepLinked ? 1 : 0));
    return __buf.array();
  }

}
```
We can observe that the documentation for the fields has been inferred from the Rust documentation (you can disable this by adding the argument 'no_doc' to the container attribute) and that a number of constraints have been applied to the fields. Following this, we can simply call 'asBytes' on our class and then provide the buffer to our FFI function.

The subsequent Rust derivation is:
```rust
impl bytebridge::ByteCodec for Configuration {
    fn try_from_bytes(
        bytes: &mut bytebridge::BytesMut,
    ) -> Result<Self, bytebridge::FromBytesError>
    where
        Self: Sized,
    {
        Ok(Test {
            runtime_empty_timeout:
                <std::time::Duration as bytebridge::ByteCodec>::try_from_bytes(bytes)?,
            runtime_attachment_queue_size: <i64 as bytebridge::ByteCodec>::try_from_bytes(
                bytes,
            )?,
            runtime_abort_on_bad_frames: <bool as bytebridge::ByteCodec>::try_from_bytes(
                bytes,
            )?,
            runtime_remote_buffer_size: <i64 as bytebridge::ByteCodec>::try_from_bytes(bytes)?,
            runtime_downlink_buffer_size: <i64 as bytebridge::ByteCodec>::try_from_bytes(
                bytes,
            )?,
            downlink_events_when_not_synced: <bool as bytebridge::ByteCodec>::try_from_bytes(
                bytes,
            )?,
            downlink_terminate_on_unlinked: <bool as bytebridge::ByteCodec>::try_from_bytes(
                bytes,
            )?,
            downlink_buffer_size: <i64 as bytebridge::ByteCodec>::try_from_bytes(bytes)?,
            keep_linked: <bool as bytebridge::ByteCodec>::try_from_bytes(bytes)?,
        })
    }
    fn to_bytes(&self, bytes: &mut bytebridge::BytesMut) {
        let Configuration {
            runtime_empty_timeout,
            runtime_attachment_queue_size,
            runtime_abort_on_bad_frames,
            runtime_remote_buffer_size,
            runtime_downlink_buffer_size,
            downlink_events_when_not_synced,
            downlink_terminate_on_unlinked,
            downlink_buffer_size,
            keep_linked,
        } = self;
        bytebridge::ByteCodec::to_bytes(runtime_empty_timeout, bytes);
        bytebridge::ByteCodec::to_bytes(runtime_attachment_queue_size, bytes);
        bytebridge::ByteCodec::to_bytes(runtime_abort_on_bad_frames, bytes);
        bytebridge::ByteCodec::to_bytes(runtime_remote_buffer_size, bytes);
        bytebridge::ByteCodec::to_bytes(runtime_downlink_buffer_size, bytes);
        bytebridge::ByteCodec::to_bytes(downlink_events_when_not_synced, bytes);
        bytebridge::ByteCodec::to_bytes(downlink_terminate_on_unlinked, bytes);
        bytebridge::ByteCodec::to_bytes(downlink_buffer_size, bytes);
        bytebridge::ByteCodec::to_bytes(keep_linked, bytes);
    }
}
```

## Type mappings:
- String
- Primitives
  - i8 -> byte
  - i32 -> int
  - i64 -> long
  - u8 -> byte > 0
  - u32 -> int > 0
  - u64 -> long > 0
  - f32 -> float
  - f64 -> double
  - NonZeroU32 -> int > 0
  - NonZeroU64 -> long > 0
  - bool -> boolean
- Array of primitive types -> Vec
- std::time::Duration -> int > 0