/*
 * Copyright 2015-2024 Swim Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package ai.swim.server.buffer;

import java.nio.BufferOverflowException;
import java.nio.BufferUnderflowException;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;

/**
 * A channel used to communicate with a Rust runtime.
 * <p>
 * This channel is intended to be driven by the Rust runtime for incrementally decoding frames and returning responses
 * that have been generated by the Java runtime. An execution flow may look like:
 * <ul>
 *   <li>Rust creates a new Java agent. During the instantiation, it is provided with a heap-backed {@link ByteBuffer} that
 *   is backed by a {@code Vec<u8>}.
 *   </li>
 *   <li>The Rust runtime receives a large WARP envelope that cannot be entirely fit in the {@link ByteBuffer}'s region.
 *   Multiple decoding invocations are required and with each decode invocation {@link JniChannel#free} is invoked with
 *   the number of bytes that could fit inside the {@link ByteBuffer}. Acting as a circular buffer allows for the decode
 *   operations to be incremental and for partial writes to be performed by the Rust runtime.</li>
 *   <li>The Java runtime finishes decoding the envelope and then clears this {@link JniChannel} and then encodes the
 *   responses that were generated. Any writes are made from the start of the allocated memory region.</li>
 *   <li>Rust incrementally decodes the responses and potentially makes further calls back to the Java runtime to flush
 *   any pending bytes into the {@link JniChannel}.</li>
 * </ul>
 * <p>
 * This class's reader functions as a circular buffer and ensures that only the region that has been marked as available
 * through {@link JniChannel#free} can be read.
 * <p>
 * Note: this class is not thread safe.
 */
public class JniChannel {
  private final ByteBuffer buffer;
  private int readPointer;
  private int readRemaining;

  private JniChannel(ByteBuffer buffer) {
    this.buffer = buffer;
  }

  public static JniChannel fromByteBuffer(ByteBuffer buffer) {
    if (buffer.order() != ByteOrder.BIG_ENDIAN) {
      throw new IllegalArgumentException("ByteBuffer's byte order must be big endian");
    }

    return new JniChannel(buffer);
  }

  public ByteReader reader() {
    return new Reader(this);
  }

  public ByteWriter writer() {
    return new Writer(this);
  }

  /**
   * Frees the next {@code count} elements from the current read pointer.
   *
   * @param count number of elements to free.
   * @return this.
   */
  public JniChannel free(int count) {
    if (readRemaining + count > buffer.capacity()) {
      throw new BufferOverflowException();
    } else {
      readRemaining += count;
      return this;
    }
  }

  public JniChannel clear() {
    buffer.clear();
    readPointer = 0;
    readRemaining = 0;
    return this;
  }

  private static class Reader implements ByteReader {
    private final JniChannel channel;

    public Reader(JniChannel channel) {
      this.channel = channel;
    }

    @Override
    public byte getByte() {
      if (remaining() == 0) {
        throw new BufferUnderflowException();
      } else {
        byte val = channel.buffer.get(channel.readPointer);
        advance(1);
        return val;
      }
    }

    @Override
    public byte peekByte() {
      return peekByte(0);
    }

    @Override
    public byte peekByte(int offset) {
      ByteBuffer buffer = this.channel.buffer;
      int readPointer = this.channel.readPointer;

      if (offset < 0) {
        throw new IllegalArgumentException();
      } else if (remaining() == 0 || remaining() < offset) {
        throw new BufferUnderflowException();
      } else {
        int idx = (offset + readPointer) % buffer.capacity();
        return buffer.get(idx);
      }
    }

    @Override
    public int getInt() {
      ByteBuffer buffer = this.channel.buffer;
      int readPointer = this.channel.readPointer;

      if (remaining() < 4) {
        throw new BufferUnderflowException();
      } else if (buffer.capacity() - readPointer > 4) {
        int val = buffer.getInt(readPointer);
        advance(4);
        return val;
      } else {
        int a = (getByte() & 0xff) << 24;
        int b = (getByte() & 0xff) << 16;
        int c = (getByte() & 0xff) << 8;
        int d = getByte() & 0xff;
        return a | b | c | d;
      }
    }

    @Override
    public int peekInt() {
      ByteBuffer buffer = this.channel.buffer;
      int readPointer = this.channel.readPointer;

      if (remaining() < 4) {
        throw new BufferUnderflowException();
      } else if (buffer.capacity() - readPointer > 4) {
        int startPosition = buffer.position();
        int val = buffer.getInt(readPointer);
        buffer.position(startPosition);
        return val;
      } else {
        int a = (peekByte() & 0xff) << 24;
        int b = (peekByte(1) & 0xff) << 16;
        int c = (peekByte(2) & 0xff) << 8;
        int d = peekByte(3) & 0xff;
        return a | b | c | d;
      }
    }

    @Override
    public long getLong() {
      if (remaining() < 8) {
        throw new BufferUnderflowException();
      }

      long a = (long) (getByte() & 0xff) << 56;
      long b = (long) (getByte() & 0xff) << 48;
      long c = (long) (getByte() & 0xff) << 40;
      long d = (long) (getByte() & 0xff) << 32;
      long e = (long) (getByte() & 0xff) << 24;
      long f = (long) (getByte() & 0xff) << 16;
      long g = (long) (getByte() & 0xff) << 8;
      long h = (long) getByte() & 0xff;
      return a | b | c | d | e | f | g | h;
    }

    @Override
    public long peekLong() {
      if (remaining() < 8) {
        throw new BufferUnderflowException();
      }

      long a = (long) (peekByte() & 0xff) << 56;
      long b = (long) (peekByte(1) & 0xff) << 48;
      long c = (long) (peekByte(2) & 0xff) << 40;
      long d = (long) (peekByte(3) & 0xff) << 32;
      long e = (long) (peekByte(4) & 0xff) << 24;
      long f = (long) (peekByte(5) & 0xff) << 16;
      long g = (long) (peekByte(6) & 0xff) << 8;
      long h = (long) peekByte(7) & 0xff;
      return a | b | c | d | e | f | g | h;
    }

    @Override
    public void advance(int by) {
      if (remaining() - by < 0) {
        throw new BufferUnderflowException();
      } else {
        channel.readRemaining -= by;
        channel.readPointer = (channel.readPointer + by) % channel.buffer.capacity();
      }
    }

    @Override
    public int remaining() {
      return channel.readRemaining;
    }
  }

  private static class Writer implements ByteWriter {
    private final JniChannel channel;

    public Writer(JniChannel channel) {
      this.channel = channel;
    }

    @Override
    public void writeByte(byte b) {
      writeByte(b, channel.buffer.remaining());
    }

    @Override
    public void writeByte(byte b, int at) {
      channel.buffer.put(at, b);
    }

    @Override
    public void writeInteger(int b) {
      channel.buffer.putInt(b);
    }

    @Override
    public void writeInteger(int b, int startAt) {
      channel.buffer.putInt(startAt, b);
    }

    @Override
    public void writeLong(long l) {
      channel.buffer.putLong(l);
    }

    @Override
    public void writeLong(long l, int startAt) {
      channel.buffer.putLong(startAt, l);
    }

    @Override
    public int remaining() {
      return channel.buffer.remaining();
    }
  }

}
